parameters:
  - name: environment
    type: string
  - name: imageRepository
    type: string
  - name: tag
    type: string

steps:
  - task: DownloadPipelineArtifact@2
    displayName: 'Download Terraform Outputs'
    inputs:
      buildType: 'current'
      artifactName: 'terraform-outputs-${{ parameters.environment }}'
      targetPath: '$(Pipeline.Workspace)'

  - task: AzureCLI@2
    displayName: 'Deploy python-webapp to AKS'
    inputs:
      azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        set -e

        if ! command -v kubelogin &> /dev/null; then
          echo "kubelogin not found, installing..."
          sudo az aks install-cli
        fi

        echo "Reading Terraform outputs..."
        ACR_SERVER=$(jq -r '.acr_login_server.value' $(Pipeline.Workspace)/outputs.json)
        AKS_NAME=$(jq -r '.aks_cluster_name.value' $(Pipeline.Workspace)/outputs.json)
        RG_NAME=$(jq -r '.resource_group_name.value' $(Pipeline.Workspace)/outputs.json)

        APP_NAME=python-webapp
        NAMESPACE=${{ parameters.environment }}

        echo "-----------------------------------"
        echo "AKS Cluster : $AKS_NAME"
        echo "ResourceGrp : $RG_NAME"
        echo "Namespace  : $NAMESPACE"
        echo "Image      : $ACR_SERVER/${{ parameters.imageRepository }}:${{ parameters.tag }}"
        echo "-----------------------------------"

        # Get AKS credentials
        az aks get-credentials \
          --resource-group $RG_NAME \
          --name $AKS_NAME \
          --overwrite-existing

        export KUBECONFIG=~/.kube/config
        kubelogin convert-kubeconfig -l azurecli

        # Create namespace if it does not exist
        kubectl create namespace $NAMESPACE \
          --dry-run=client -o yaml | kubectl apply -f -

        # ---------------------------------------------------
        # Update image in deployment (temporary approach)
        # ---------------------------------------------------
        echo "Updating image in deployment.yaml"
        sed -i "s|image:.*$|image: $ACR_SERVER/${{ parameters.imageRepository }}:${{ parameters.tag }}|g" kubernetes/base/deployment.yaml

        # ---------------------------------------------------
        # Apply Kubernetes manifests
        # ---------------------------------------------------
        kubectl apply -f kubernetes/base/deployment.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/service.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/hpa.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/network-policy.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/pdb.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/ingress.yaml -n $NAMESPACE

        # ---------------------------------------------------
        # Wait for rollout
        # ---------------------------------------------------
        echo "Waiting for deployment rollout..."
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=5m

        # ---------------------------------------------------
        # Get the Ingress Controller IP
        # ---------------------------------------------------
        echo "Waiting for Ingress Public IP..."
        
        # We look in the 'ingress-nginx' namespace because that is where Terraform installed it
        INGRESS_NS="ingress-nginx"
        INGRESS_SVC="ingress-nginx-controller"

        for i in {1..30}; do
          EXTERNAL_IP=$(kubectl get svc $INGRESS_SVC \
            -n $INGRESS_NS \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)

          if [ -n "$EXTERNAL_IP" ]; then
            break
          fi
          echo "Still waiting for IP... (Attempt $i/30)"
          sleep 10
        done

        echo "---------------------------------------------------"
        if [ -z "$EXTERNAL_IP" ]; then
          echo "LoadBalancer IP not assigned yet. Check Azure Portal."
        else
          echo "DEPLOYMENT SUCCESSFUL!"
          echo "Your app is accessible at: http://$EXTERNAL_IP"
          echo "Note: If you have a domain, point it to this IP."
        fi
        echo "---------------------------------------------------"