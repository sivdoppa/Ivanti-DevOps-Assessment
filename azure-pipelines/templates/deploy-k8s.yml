parameters:
  - name: environment
    type: string
  - name: imageRepository
    type: string
  - name: tag
    type: string

steps:
  - task: DownloadPipelineArtifact@2
    displayName: 'Download Terraform Outputs'
    inputs:
      buildType: 'current'
      artifactName: 'terraform-outputs-${{ parameters.environment }}'
      targetPath: '$(Pipeline.Workspace)'

  - task: AzureCLI@2
    displayName: 'Deploy python-webapp to AKS'
    inputs:
      azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        set -e

        if ! command -v kubelogin &> /dev/null; then
          echo "kubelogin not found, installing..."
          sudo az aks install-cli
        fi

        echo "Reading Terraform outputs..."
        ACR_SERVER=$(jq -r '.acr_login_server.value' $(Pipeline.Workspace)/outputs.json)
        AKS_NAME=$(jq -r '.aks_cluster_name.value' $(Pipeline.Workspace)/outputs.json)
        RG_NAME=$(jq -r '.resource_group_name.value' $(Pipeline.Workspace)/outputs.json)

        APP_NAME=python-webapp
        NAMESPACE=${{ parameters.environment }}

        echo "-----------------------------------"
        echo "AKS Cluster : $AKS_NAME"
        echo "ResourceGrp : $RG_NAME"
        echo "Namespace  : $NAMESPACE"
        echo "Image      : $ACR_SERVER/${{ parameters.imageRepository }}:${{ parameters.tag }}"
        echo "-----------------------------------"

        # Get AKS credentials
        az aks get-credentials \
          --resource-group $RG_NAME \
          --name $AKS_NAME \
          --overwrite-existing

        export KUBECONFIG=~/.kube/config
        kubelogin convert-kubeconfig -l azurecli
        
        # Create namespace if it does not exist
        kubectl create namespace $NAMESPACE \
          --dry-run=client -o yaml | kubectl apply -f -

        # ---------------------------------------------------
        # Update image in deployment (temporary approach)
        # ---------------------------------------------------
        echo "Updating image in deployment.yaml"
        sed -i "s|image:.*$|image: $ACR_SERVER/${{ parameters.imageRepository }}:${{ parameters.tag }}|g" kubernetes/base/deployment.yaml

        # ---------------------------------------------------
        # Apply Kubernetes manifests
        # ---------------------------------------------------
        kubectl apply -f kubernetes/base/deployment.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/service.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/hpa.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/network-policy.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/pdb.yaml -n $NAMESPACE
        kubectl apply -f kubernetes/base/ingress.yaml -n $NAMESPACE

        # ---------------------------------------------------
        # Wait for rollout
        # ---------------------------------------------------
        echo "Waiting for deployment rollout..."
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=5m

        # ---------------------------------------------------
        # Try to get LoadBalancer IP (non-blocking)
        # ---------------------------------------------------
        echo "Waiting for LoadBalancer IP..."
        for i in {1..20}; do
          EXTERNAL_IP=$(kubectl get svc ${APP_NAME}-service \
            -n $NAMESPACE \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)

          if [ -n "$EXTERNAL_IP" ]; then
            break
          fi

          sleep 15
        done

        if [ -z "$EXTERNAL_IP" ]; then
          echo "LoadBalancer IP not assigned yet"
        else
          echo "Service available at: http://$EXTERNAL_IP"
        fi

        # ---------------------------------------------------
        # Ingress info (if configured)
        # ---------------------------------------------------
        echo "If ingress is configured, access via:"
        echo "https://webapp.yourdomain.com"

        echo "Deployment completed successfully."
      
  # - task: Kubernetes@1
  #   displayName: 'Get Deployment Status'
  #   inputs:
  #     connectionType: 'Azure Resource Manager'
  #     azureSubscriptionEndpoint: 'azure-service-connection'
  #     azureResourceGroup: '$(cat $(Pipeline.Workspace)/outputs.json | jq -r .resource_group_name.value)'
  #     kubernetesCluster: '$(cat $(Pipeline.Workspace)/outputs.json | jq -r .aks_cluster_name.value)'
  #     namespace: '${{ parameters.environment }}'
  #     command: 'get'
  #     arguments: 'all'